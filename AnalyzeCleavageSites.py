# -*- coding: utf-8 -*-
"""
Created on Thu Oct 20 15:42:28 2022

@author: Philipp

v1.0.2
Changelog
- v1.0.0 first release
- v1.0.1 minor bugfixes
- v1.0.2 include ambiguous subsequence proteoforms (can arise from multiple 
            proteins) if proteins have the same potential cleavage site
- v1.0.3 visualization: added histograms to heatmap 
- v2.0.0 added protein analysis
"""


import pandas as pd
from collections import Counter
from itertools import groupby
from operator import itemgetter


import ReadProteoforms
import ReadFastaFile
from MyPlots import create_cleavage_site_plot, truncations_pi_chart, \
    plot_methionin_cleaveage, plot_methionin_cleavaege_absolut
from Settings import Settings
from Tools import check_multiple_lists_are_identical, \
    only_one_unique_element_in_list
from ShowDataFrame import show_dataframe


class AnalyzeCleavageSites:
    def __init__(self, fasta_file):
        self.ReadFastaFile = ReadFastaFile.ReadFastaFile()
        self.fasta_dict = self.ReadFastaFile.read_fasta_file(fasta_file)

    
		
    def find_subsequence_in_full_sequence(self, subsequence: str, 
                                          full_sequence: str) -> [int, int]:
        """
        Returns position of subsequence which is within annotated sequence

        Parameters
        ----------
        subsequence : str
            Subsequence proteoform sequence.
        full_sequence : str
            Annotated proteoform sequence. 

        Returns
        -------
        [int, int]
            Start and endposition (first amini acid: 0) of subsequence 
            proteoform in relation to annotated proteoform.

        """
        start_pos = full_sequence.find(subsequence)
        end_pos = start_pos + len(subsequence) 
        return start_pos, end_pos
		
		
		
    def check_nterminal_truncation(self, start_pos):
        """ True if N-terminal truncatated """
        return start_pos != 0 and start_pos != 1
    
    
    
    def check_cterminal_truncation(self, full_sequence, end_pos):
        """ True if N-terminal truncatated """
        return end_pos != len(full_sequence)
		
    
    def check_truncations(self, truncations, full_sequence, start_pos, end_pos): 
        #truncations = {"N-term": 0, "C-term": 0, "N- and C-term": 0, "Full length": 0}
        n_term_truncation = self.check_nterminal_truncation(start_pos)
        c_term_truncation = self.check_cterminal_truncation(full_sequence, end_pos)
        if n_term_truncation and c_term_truncation:
            truncations[0] += 1
        elif n_term_truncation and not c_term_truncation:
            truncations[1] += 1
        elif c_term_truncation and not n_term_truncation:
            truncations[2] += 1
        elif not c_term_truncation and not n_term_truncation:
            truncations[3] += 1
        return truncations
    
    
    def check_specificity(self, full_sequence, start_pos, end_pos, 
                          specificity = ["D", "E"]):
        if not self.check_cterminal_truncation(full_sequence, end_pos):
            c_term_specific = True
        elif full_sequence[end_pos - 1] in specificity:
            c_term_specific = True
        else:
            c_term_specific = False
        if not self.check_nterminal_truncation(start_pos):
            n_term_specific = True
        elif full_sequence[start_pos - 1] in specificity:
            n_term_specific = True
        else:
            n_term_specific = False

        return n_term_specific, c_term_specific
        
    
    
    
    def _anylaze_methionine_cleavage(self, start_pos, full_sequence):
        # [cleaved, not_cleaved]
        cleaved = False
        not_cleaved = False
        if start_pos == 0:
            not_cleaved = full_sequence[1]
        elif start_pos == 1:
            cleaved = full_sequence[1]
        else:
            pass
        return [cleaved, not_cleaved]
    
    
    def find_cleavage_sites(self, subsequence: str, full_sequence: str) -> [list]:
        """
        Returns cleavage site (X|X') of subsequence within annotated  proteoform.
        If subsequence proteoform is generated by N- and C-terminal truncations, 
        both cleavage sites are returned 

        Parameters
        ----------
        subsequence : str
            Subsequence proteoform sequence.
        full_sequence : str
            Annotated proteoform sequence. 

        Returns
        -------
        list
            Contains potential cleavage sites as [[X|X'], [X|X']]

        """
        start_pos, end_pos = self.find_subsequence_in_full_sequence(subsequence, 
                                                                full_sequence)
        cleav_list = []
        if self.check_cterminal_truncation(full_sequence, end_pos): 
            x = full_sequence[end_pos - 1]
            x_prime = full_sequence[end_pos]
            cleav_list.append([x, x_prime])
        # N-terminal truncated
        if self.check_nterminal_truncation(start_pos):  
            x = full_sequence[start_pos - 1]
            x_prime = full_sequence[start_pos]
            cleav_list.append([x, x_prime])
        return cleav_list



    def _check_multiple_lists_are_identical(self, ll):
        if len(ll) == 0: return True
        h1 = []
        l1 = ll[0]
        for l2 in ll[1:]:
            h1.append(sorted(l1) == sorted(l2))
        return False if False in h1 else True

    

    def _show_progress(self, i, total):
        if i%500 == 0: 
            print ("{} (= {:.0%}) proteoforms processed".format(i, i/total))


    def determine_specificity(self, specificity): 
        spec = ""
        n_term, c_term = specificity
        if n_term and c_term: spec = "Full-specific"
        elif n_term and not c_term: spec = "Semi-specific" #"Semi Specific N-term"
        elif not n_term and c_term: spec = "Semi-specific" #"Semi Specific C-term"
        elif not n_term and not c_term: spec = "Un-specific"
        return spec



    def find_subsequence_termini(self, sequences, prsms): 
        """ all proteoforms, that were not identified in annotated proteoform
            search, level = proteoform or prsms ->  
            # Proteoform-Level: Count #Proteoforms, PrSMs-Level: Count #PrSMs """
        number_sequences = len(sequences)
        aa_df = pd.DataFrame(0, columns = Settings.aa_list, index = Settings.aa_list)
        ambigious = 0
        number_considered_subsequence_proteoforms = 0
        # truncations = [N-term, C-term, N- and C-term, Full length]
        truncations = [0, 0, 0, 0]
        # protease specificity
        protease_specificity = {"Full-specific": 0, "Semi-specific": 0, 
                                "Un-specific": 0}
        # {Accession: [Full_Sequence, [StartPos1, Endpos1, sequence, #prms], ...]}
        accession_proteoforms = {}
        # Methionin cleavaed [[cleaved], [not-cleaved]]
        met_cleav = {Settings.not_cleaved: [], Settings.cleaved: []}
        ### for icelogos
        nterm_icelogo, cterm_icelogo  = [], []
        for index, (sequence, prsm) in enumerate(zip(sequences, prsms)):
            self._show_progress(index, number_sequences)
            prots = self.ReadFastaFile.find_sequence(self.fasta_dict, 
                                                     sequence)
            counter_ = 1 
            if len(prots) > 1: 
                # print("Ambiguous sequence (sequence proteoform can "
                #       "arise from multiple proteins): ", prots, sequence)
                ambigious += 1 
            elif len(prots) == 0: 
                print(sequence, "not found in fasta file")
                continue
            # if multiple proteins, check if all have the same potential cleavage site
            nterm_x_sites, cterm_x_sites = [], []
            nterm_x_prime_sites, cterm_x_prime_sites = [], []
            specificity_terms = []
            # if multiple proteins, check if all have the same truncation
            truncations_temp = []
            # check for each protein from which the sequence proteoform 
            # can arise the X|X' position 
            for accession in prots:
                full_sequence = self.ReadFastaFile.find_protein(self.fasta_dict, 
                                                                    accession)
                start_pos, end_pos = self.find_subsequence_in_full_sequence\
                                                    (sequence, full_sequence)
                if accession not in accession_proteoforms: 
                    accession_proteoforms[accession] = [full_sequence, []]
                accession_proteoforms[accession][1].append([start_pos, end_pos,
                                                            sequence, prsm])
                truncations_temp.append(self.check_truncations([0,0,0,0], 
                                        full_sequence, start_pos, end_pos))
                #C-terminal truncation?
                if self.check_cterminal_truncation(full_sequence, end_pos): 
                    x = full_sequence[end_pos - 1]
                    x_prime = full_sequence[end_pos]
                    cterm_x_sites.append(x)
                    cterm_x_prime_sites.append(x_prime)
                # N-terminal truncation? 
                if self.check_nterminal_truncation(start_pos):  
                    x = full_sequence[start_pos - 1]
                    x_prime = full_sequence[start_pos]
                    nterm_x_sites.append(x)
                    nterm_x_prime_sites.append(x_prime)
                # Specificity
                specificity_term = \
                    self.check_specificity(full_sequence, start_pos, end_pos)
                specificity_terms.append(specificity_term)
            # consider X|X' if X|X' for all possible proteins is equal 
            if only_one_unique_element_in_list(cterm_x_prime_sites): 
                    aa_df[cterm_x_sites[0]][cterm_x_prime_sites[0]] += counter_
                    pos = full_sequence.find(sequence)
                    res = full_sequence[pos+len(sequence)-5:pos+len(sequence)+5]
                    cterm_icelogo.append(res)
                    # print("cterm_x_prime_sites",res)
            if only_one_unique_element_in_list(nterm_x_sites): 
                    aa_df[nterm_x_sites[0]][nterm_x_prime_sites[0]] += counter_
                    pos = full_sequence.find(sequence)
                    res = full_sequence[pos-5:pos+5]
                    nterm_icelogo.append(res)
                    # print("nterm_x_sites",res)
            if only_one_unique_element_in_list(nterm_x_sites) or \
                only_one_unique_element_in_list(cterm_x_prime_sites):
                    number_considered_subsequence_proteoforms += 1
                    
            if only_one_unique_element_in_list(specificity_terms):
                specificity = self.determine_specificity(specificity_terms[0])
                protease_specificity[specificity] += 1
            # consider truncation only if for all possible proteins the same
            if check_multiple_lists_are_identical(truncations_temp):
                truncations = [i + j for i, j in zip(truncations, truncations_temp[0])]
                # Methionine-cleavage 
                cleaved, not_cleaved = self._anylaze_methionine_cleavage(start_pos, 
                                                                    full_sequence)
                if cleaved: met_cleav[Settings.cleaved].append(cleaved) 
                if not_cleaved: met_cleav[Settings.not_cleaved].append(not_cleaved)
        aa_df = aa_df.T
        aa_df = aa_df.sort_index(ascending=False)
        
        print("Considered Proteoforms", number_considered_subsequence_proteoforms)
        print("Total potential cleavage events: {}".format(aa_df.sum().sum()))
        
        data_icelogo_df = pd.DataFrame(zip(nterm_icelogo, cterm_icelogo))
        data_icelogo_df.columns=["N-term", "C-term"]
        # df.to_csv("E:\\icelogos.csv")
        
        # protein_groups_properties = self.analyze_sequence_coverage(accession_proteoforms)
        # self.visualize_dataframe(protein_groups_properties)
        return(aa_df, accession_proteoforms, truncations, met_cleav, 
               protease_specificity, data_icelogo_df)
    
    
    
    def binaric_visualization(self, coverage, sequence_length, vis_length = 100):
        """ """
        rel_length = vis_length / sequence_length
        visualization_binaric = [0 for i in range(vis_length)]
        for k, g in groupby(enumerate(coverage), lambda ix : ix[0] - ix[1]): 
            consecutive_list = list(map(itemgetter(1), g))
            # print(consecutive_list)
            rel_pos_start = int(round(consecutive_list[0] * rel_length))
            rel_pos_end = int(round(consecutive_list[-1] * rel_length))
            for j in range(rel_pos_start - 1, rel_pos_end):
                visualization_binaric[j] = 1
        visualization_string = []
        for i in visualization_binaric:
            if i == 0:
                visualization_string.append(" ")
            elif i == 1:
                visualization_string.append(".")
    
        visualization = "".join(visualization_string)
        return visualization
    
    
    
    
    
    def visualize_dataframe(self, protein_groups_properties):
        df = pd.DataFrame.from_dict(protein_groups_properties, orient ="index")
        df.columns = ["Protein Accession", "Sequence Coverage / %", "#Peptides", 
                      "Sequence Length", "#Glutamate", "Visualization"]
        df["Sequence Coverage / %"] = df["Sequence Coverage / %"] * 100
        show_dataframe(df)





    def analyze_sequence_coverage(self, accession_proteoforms):
        protein_groups_properties = {}
        for accession in accession_proteoforms:
            full_sequence = accession_proteoforms[accession][0]
            cov = []
            starts, ends, sequences, psms = list(zip(*accession_proteoforms[accession][1]))
            for s, e in zip(starts, ends):
                cov.extend([i for i in range(s, e)])
            # print(list(set(cov)), len(full_sequence))
            coverage = list(set(cov))
            seq_cov = len(coverage)/len(full_sequence)
            
            vis = self.binaric_visualization(coverage, len(full_sequence))
            protein_groups_properties[accession] = [accession, seq_cov, len(sequences), 
                                       len(full_sequence), 
                                       Counter(full_sequence)["E"],
                                       vis]
            
        return protein_groups_properties
        
        
    
    
    def analyze_aa_content_in_database(self):
        """ """
        sequences  = list(self.fasta_dict.values())
        df = pd.DataFrame(0, columns=Settings.aa_list, index=Settings.aa_list)
        aa_dict = {}
        for aa in Settings.aa_list:
            aa_dict[aa] = {}
            for aa2 in list(reversed(Settings.aa_list)):
                aa_dict[aa][aa2] = 0
        for sequence in sequences:
            for index, aa in enumerate(sequence[0:-1]):
                aa_1 = sequence[index]
                aa_2 = sequence[index + 1]
                aa_dict[aa_2][aa_1] += 1
        df = pd.DataFrame(aa_dict)
        print(df)
        create_cleavage_site_plot(df)
        return df
    
    
    def save_data(self, df, file_name):
        df.to_csv(file_name)
        print(file_name, "successfully saved")
            
